using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


namespace Huffman_Algorithm
{
    class Node
    {
        public Node Left { get; set; } = null;
        public Node Right { get; set; } = null;
        public int Freq { get; set; } = 0;
        public string Symbol { get; set; } = "null";


    }
    class Algorithm
    {
        public List<Node> FromFileToList(string path)
        {
            string chars = File.ReadAllText(path);
            char[] charsarray = chars.ToCharArray();
            List<Node> l = new List<Node>();
            foreach (var c in charsarray)
            {
                if(!l.Any(n=>n.Symbol == c.ToString()))
                    l.Add(new Node(){Freq = charsarray.Count(n=>n==c) , Symbol = c.ToString() });
            }
            return l;

        }

        
        public void Huffman(string path)
        {
            List<Node> nodes = FromFileToList(path);
            int number = nodes.Count;
            for (int i = 1; i < number; i++)
            {
                Node x = Extract_Min(nodes);
                nodes.Remove(x);
                Node y = Extract_Min(nodes);
                nodes.Remove(y);
                Node z = new Node();
                z.Left = x;
                z.Right = y;
                z.Freq = x.Freq + y.Freq;
                nodes.Add(z);
            }

            printCode(Extract_Min(nodes),"");
            Console.WriteLine();
            draw_tree_hor(Extract_Min(nodes));
            Console.WriteLine("\n------Porownianie dlugosci-----");
            Console.WriteLine("Kody o stale dlugosci: "+length);
            Console.WriteLine("kod Huffmana: "+huffLength);
        }

        Dictionary<Node,string> dic = new Dictionary<Node,string>();
        private double length = 8*355;
        private double huffLength;
        public void printCode(Node root, String s)
        {

            // base case; if the left and right are null 
            // then its a leaf node and we print 
            // the code s generated by traversing the tree. 
            if (root.Left == null && root.Right == null && !root.Symbol.Equals("null"))
            {

                // c is the character in the node 
                Console.WriteLine("SYMBOL: " + root.Symbol +" Czestotliwosc: "+root.Freq +" Kod: " + s);
                dic.Add(root,s);
                huffLength += root.Freq * s.Length;
                return ;
            }

            // if we go to left then add "0" to the code. 
            // if we go to the right add"1" to the code. 

            // recursive calls for left and 
            // right sub-tree of the generated tree. 
            printCode(root.Left, s + "0");
            printCode(root.Right, s + "1");
        }

        private static Node Extract_Min(List<Node> nodes)
        {
            return (Node)(from n in nodes
                where n.Freq == nodes.Min(m => m.Freq)
                select n).First();
            //return (Node)nodes.Where(n => n.freq.Equals(nodes.Min(m => m.freq)));
        }


        private readonly int space = 10;
        void draw_tree_hor2(Node tree, int distance)
        {
            if (tree == null)
                return;

            distance += space;

            draw_tree_hor2(tree.Right, distance);


            Console.Write("\n");

            for (int i = space; i < distance; i++)
                Console.Write(" ");
            Console.Write(tree.Symbol + ":");

            Console.Write(tree.Freq + "\n");

            draw_tree_hor2(tree.Left, distance);
        }


        void draw_tree_hor(Node tree)
        {
            draw_tree_hor2(tree, 0);
        }
    }
}
