using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


namespace Huffman_Algorithm
{
    class Node
    {
        public Node Left { get; set; } = null;
        public Node Right { get; set; } = null;
        public int Freq { get; set; } = 0;
        public string Symbol { get; set; } = "null";


    }
    class Algorithm
    {
        public List<Node> FromFileToList(string path, bool mode)
        {
            List<Node> l = new List<Node>();
            List<string> charCombination = new List<string>();
            string chars = File.ReadAllText(path);
            if (mode == true)
            {
               
                if (chars.Length % 2 != 0)
                    chars += "1";

                 char[] charsarray = chars.ToCharArray();
                 for (int i = 0; i < charsarray.Length; i++)
                 {
                     for (int j = 0; j < charsarray.Length; j++)
                     {
                          string s = charsarray[i].ToString() + charsarray[j].ToString();
                         charCombination.Add(s);
                     }
                 }
            }
            else
            {
                length = 8 * 355;
                for (int i = 0; i < chars.Length; i++)
                {
                    charCombination.Add(chars[i].ToString());
                }
            }
            foreach (var c in charCombination)
            {
                if(!l.Any(n=>n.Symbol.Equals(c)))
                    l.Add(new Node(){Freq = charCombination.Count(n=>n.Equals(c)) , Symbol = c});
            }

            var le = l.Max(p => p.Freq);
            length = 8 * le.ToString().Length * 355;
            return l;

        }

        
        public void Huffman(string path,bool mode)
        {
           List<Node> nodes = FromFileToList(path,mode);
    
            int number = nodes.Count;
            for (int i = 1; i < number; i++)
            {
                Node x = Extract_Min(nodes);
                nodes.Remove(x);
                Node y = Extract_Min(nodes);
                nodes.Remove(y);
                Node z = new Node();
                z.Left = x;
                z.Right = y;
                z.Freq = x.Freq + y.Freq;
                nodes.Add(z);
            }

            printCode(Extract_Min(nodes),"");
            Console.WriteLine();
            draw_tree_hor(Extract_Min(nodes));
            Console.WriteLine("\n------Porownianie dlugosci-----");
            Console.WriteLine("Kody o stale dlugosci: "+length);
            Console.WriteLine("kod Huffmana: "+huffLength);
        }

        Dictionary<Node,string> dic = new Dictionary<Node,string>();
        private double length;
        private double huffLength;
        public void printCode(Node root, String s)
        {

            // base case; if the left and right are null 
            // then its a leaf node and we print 
            // the code s generated by traversing the tree. 
            if (root.Left == null && root.Right == null && !root.Symbol.Equals("null"))
            {

                // c is the character in the node 
                Console.WriteLine("SYMBOL: " + root.Symbol +" Czestotliwosc: "+root.Freq +" Kod: " + s);
                dic.Add(root,s);
                huffLength += root.Freq * s.Length;
                return ;
            }

            // if we go to left then add "0" to the code. 
            // if we go to the right add"1" to the code. 

            // recursive calls for left and 
            // right sub-tree of the generated tree. 
            printCode(root.Left, s + "0");
            printCode(root.Right, s + "1");
        }

        private static Node Extract_Min(List<Node> nodes)
        {
            return (Node)(from n in nodes
                where n.Freq == nodes.Min(m => m.Freq)
                select n).First();
            //return (Node)nodes.Where(n => n.freq.Equals(nodes.Min(m => m.freq)));
        }


        private readonly int space = 10;
        void draw_tree_hor2(Node tree, int distance)
        {
            if (tree == null)
                return;

            distance += space;

            draw_tree_hor2(tree.Right, distance);


            Console.Write("\n");

            for (int i = space; i < distance; i++)
                Console.Write(" ");
            Console.Write(tree.Symbol + ":");

            Console.Write(tree.Freq + "\n");

            draw_tree_hor2(tree.Left, distance);
        }


        void draw_tree_hor(Node tree)
        {
            draw_tree_hor2(tree, 0);
        }

        
    }
}
